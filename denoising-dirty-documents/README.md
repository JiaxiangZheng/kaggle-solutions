### 方法一

简单地使用中值滤波器对原始图像进行过滤，将滤波后的结果与原始图像作 diff，得到产生的背景图。这些，原始图减掉背景图就是 denoise 后的结果了。参考 `signal-denoising.py` 中的实现。对测试集运行的 MSR 误差大概在 0.06 左右。生成结果提交 Kaggle 的结果也大致在 0.06。

### 方法二

考虑到图像具有局部性，对每个目标像素，我们可以认为其原始的影响像素为该位置像素的近邻像素。因此，可以考虑以每个为中心生成一系列 patches，如大小为 23 * 23 的原始图像，目标值为 denosie 后的对应像素值。这样训练的样本量就达到了 width * heigth * train_size 了。

实验下来的感想是，与其设计更复杂的网络结构，反倒不如二层最简单的 MLP 网络 + 多种训练数据精度更高。另外，考虑到一张图片每个像素都当一个样本，就会导致训练样本过多，可以考虑每个图片使用一定的采样率，扩大受污染图像的种类。参考源代码中 `train.py`。

### 方法三

可以考虑对原始图像进行分割出一系列小的 patch 图像（允许一定的重叠区域），直接构建神经网络对 patch 图像进行训练，这样一方面训练的样本量可以扩大，另一方面可以直接学习出一个比较可靠的卷积核对图像进行过滤，生成合理的结果。

方法参考 `train.py`, `clean.py`, `sumbit.py`。